```python
# 沿行方向进行合并，结果存储在data中
data = pd.concat([test, train], axis=0, ignore_index=True)

pd.concat # pandas中的函数 沿着指定轴（行/列）连接多个DataFrame或Series
[test, train] # 包含两个DataFrame列表 要连接的对象
axis=0 # 沿着行（纵向）连接 若axis=1 沿列（横向）连接
ignore_index=True # 为合并后DataFrame生成从0开始的索引 不保留原索引 确保合并后索引连续
```

```python
# 按照指定列排序 重置索引
data = data.sort_values(['id','dt'], ascending=False).reset_index(drop=True)

.sort_values # pandas中方法 对DataFrame排序
['id', 'dt'] # 按照这两个列排序 首先按id排 id相同按dt排
ascending=False # 降序排序 True为升序排序
.reset_index # pandas方法 重置DataFrame索引
drop=True # 重置索引时丢弃原索引 而非原索引作为新列加入DataFrame中
```

```python
# 历史平移
for i in range(10,30):
    data[f'last{i}_target'] = data.groupby(['id'])['target'].shift(i)

for i in range(10,30) # 遍历整数 10 <= i < 30
data[f'last{i}_target'] # 创建一个新列名 格式last{i}_target
data.groupby(['id']) # 按id列对类别为DataFrame的data分组
['target'] # 选择target列操作
.shift(i) # 将target列中的值向下移动i个位置 移动i个位置即表示当前行的target值被替换为i个位置之前的值 如果移动位置数i大于每组数据量 无数据滞后 target全为NaN 若移动位置数i小于每组数据量 移动位置后 在那条数据后面相应位置填入滞后数据
```

^9da62a

