```python
# 沿行方向进行合并，结果存储在data中
data = pd.concat([test, train], axis=0, ignore_index=True)

pd.concat # pandas中的函数 沿着指定轴（行/列）连接多个DataFrame或Series
[test, train] # 包含两个DataFrame列表 要连接的对象
axis=0 # 沿着行（纵向）连接 若axis=1 沿列（横向）连接
ignore_index=True # 为合并后DataFrame生成从0开始的索引 不保留原索引 确保合并后索引连续

# 按照指定列排序 重置索引
data = data.sort_values(['id','dt'], ascending=False).reset_index(drop=True)

.sort_values # pandas中方法 对DataFrame排序
['id', 'dt'] # 按照这两个列排序 首先按id排 id相同按dt排
ascending=False # 降序排序 True为升序排序
.reset_index # pandas方法 重置DataFrame索引
drop=True # 重置索引时丢弃原索引 而非原索引作为新列加入DataFrame中
```

^44c787

```python
# 历史平移
for i in range(10,30):
    data[f'last{i}_target'] = data.groupby(['id'])['target'].shift(i)

for i in range(10,30) # 遍历整数 10 <= i < 30
data[f'last{i}_target'] # 创建一个新列名 格式last{i}_target
data.groupby(['id']) # 按id列对类别为DataFrame的data分组
['target'] # 选择target列操作
.shift(i) # 将target列中的值向下移动i个位置 移动i个位置即表示当前行的target值被替换为i个位置之前的值 如果移动位置数i大于每组数据量 无数据滞后 target全为NaN 若移动位置数i小于每组数据量 移动位置后 在那条数据后面相应位置填入滞后数据
```

^e0e24e

```python
# 窗口统计
data[f'win3_mean_target'] = (data['last10_target'] + data['last11_target'] + data['last12_target']) / 3 # 把三个列的平均值存储到新列win3_mean_target win3表示窗口大小为3 窗口大小的意思是有多少列
```

^08d8ec

```python
# 进行数据切分 切分成训练集train和测试集test
train = data[data.target.notnull()].reset_index(drop=True) # 包含target列不为NaN的行
test = data[data.target.isnull()].reset_index(drop=True) # 包含target列为NaN的行

data.target.notnull() # 返回1个布尔Series 表示target列中哪些值不是NaN
data[data.target.notnull()] # 使用这个布尔Series对data进行索引 返回一个只有target列值不为NaN的行的DataFrame
.reset_index(drop=True) # 重置索引时丢弃原索引 而非原索引作为新列加入DataFrame中

data.target.isnull() # 返回1个布尔Series 表示target列有哪些值为NaN
data[data.target.isnull()] # 使用这个布尔Series对data进行索引 返回一个只有target列值为NaN的行的DataFrame
.reset_index(drop=True) # 重置索引时丢弃原索引 而非原索引作为新列加入DataFrame中
```

^8c79a2

```python

```

