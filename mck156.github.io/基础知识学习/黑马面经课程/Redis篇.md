#例子 
问题：我看你做的项目中，都用到了redis，你在最近的项目中哪些场景使用了redis呢？

结合项目→
验证项目场景的真实性，二是为了作为深入发问的切入点
缓存——缓存三兄弟（穿透、击穿、雪崩）、双写一致、持久化、数据过期策略、数据淘汰策略
分布式锁——setnx、redisson
消息队列、延迟队列——何种数据类型
……

问题：如果发生缓存穿透、击穿、雪崩，该如何解决？
三个方向

## 缓存穿透
例如：一个`get`请求 `api/news/getByld/1`
正常缓存流程：根据id查询文章，查redis中有没有数据，命中数据返回结果。如果redis查询不到，在DB（数据库）中查询，DB查询到结果，把结果存储到redis中，再返回。
![[Pasted image 20240715100708.png]]
缓存穿透：查询一个不存在的数据，MySQL中查询不到数据也不会直接写入缓存，就会导致每次请求都查数据库。
为什么会出现？有人知道了缓存路径，恶意攻击系统，造假id来发起请求，比如把1改为0 or 负数，击垮数据库导致宕机。
解决方法：
1. 缓存空数据，查询返回的数据为空，仍把这个空结果进行缓存。`{key:1.value:null}`
优点：简单
缺点：消耗内存，（大量空数据缓存压力大）可能会发生数据不一致的问题
## 布隆过滤器
流程：根据id查询文章，查询布隆过滤器，布隆过滤存在，查redis（在缓存预热时，预热布隆过滤器）；不存在直接返回。
> 有一批数据是热点数据，添加到缓存中，请求也可以优先读取缓存，同时也要**添加数据到布隆过滤器**中。

优点：内存占用较少，没有多余key
缺点：实现复杂，存在误判
![[Pasted image 20240715101510.png]]
bitmap（位图）：相当于是一个以（bit）位为单位的数组，数据每个单元只能存储二进制数0或1
作用：拦截不存在的数据，即用于检索一个元素是否在一个集合中。
存储数据：id为1的数据，通过多个hash值，根据hash计算数组对应位置改为1。数组所有数据一开始初始化的时候都为0。
查询数据：使用相同的hash函数获取hash值，判断对应位置是否都为1。有一个为1即位置存在，不为1即不存在。只有0和1。
当数据为0时用布隆过滤器过滤。
![[Pasted image 20240715104119.png]]
来了一个id为3的数据（不存在），但三次查找位置都为1，即误判。
误判率：数组越小误判率越大，数组越大误判率越小同时有更多内存消耗。
![[Pasted image 20240715104506.png]]
布隆过滤器实现方案：Redisson、Guava